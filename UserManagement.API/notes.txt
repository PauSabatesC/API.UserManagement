
RUN:

-Development build
	- docker-compose -f docker-compose-debugEnv.yml build
	- docker-compose -f docker-compose-debugEnv.yml up
	- https://localhost:5001/swagger/index.html

-Production like build
	- docker-compose build
	- docker-compose up
	- https://localhost/swagger/index.html

todos:
-domain models ar anemic, so they should have all the assert validation logic of the model itself.
-dtos may be included and they might be in the application service layer, not in the domain layer.
-la interficie del repository en comptes de passar per parametres Guid passar T ja que en algunes databases no va el guid. https://www.c-sharpcorner.com/article/onion-architecture-in-asp-net-core-mvc/
-millorar el versioning
-look into token invalidation (i only do validation?)
-posar els Responses com aqui https://github.com/zkavtaskin/Domain-Driven-Design-Example/blob/master/eCommerce.WebService/Controllers/CartController.cs
-millorar seguretat de les pass del appsettings i del dockercompose
-on posar els try catch i on posar els logs
-move startup configure services to each layer.
-cache invalidation (aqui parlen https://github.com/jasontaylordev/CleanArchitecture/pull/110)

---- authentication and authorization types:

.api key (per utilitzar rollo altres developers)
	- no es util per usuaris 

.https token (quan login es genera un token que es guarda en database i a les cookies)
	- consulta cada cop a database(amb redis es pot millorar temps. es mes utilitzat per sessions rollo carrito)
	- entrada a db per cada user
	. database compartida si varies instancies del servei
	+ can expire/refresh

.jwt token (token q es genera a partir de un secret key. utilitzat en api rest per verificar que el usuari que s'ha loguejat te permissos)
	+ cada client es guarda el token, res a databases
	+ menys accessos database
	+ can expire
	- el jwt conte 3 parts(header,payload,signature) pero esta codificat amb hash base64 per tant el payload pot ser llegit i no s'hi ha de posar informaciï¿½ delicada.

.identity .net (per gestionar rols i permissos)

.oauth (per donar permissos a una third app.)




----posar al readme----


Exemples: https://fusionauth.io/ o https://auth0.com/




---Migration to Onion + DDD---

-UserManagement.Domain
	-Entities
	-Repository Interfaces
-UserManagement.Services
	-DTOs
	-Options
	-Extensions
	-Boundaries
-UserManagement.Infrastructure
	-Database
		-SQLServer
			-Migrations
-UserManagement.API
	-Controllers
		-v1
			-Contracts
				-Requests
				-Responses
				ApiRoutes.cs
	appsettings.json


	-----
	dto to domain object
	domain object to response contracts

	DTO->service->DomainObject -service->DTO
	Your service should receive DTOs, map them to business entities and send them to the repository. 
	It should also retrieve business entities from the repository, map them to DTOs and return the DTOs as reponses.
	So your business entities never get out from the business layer, only the DTOs do.
